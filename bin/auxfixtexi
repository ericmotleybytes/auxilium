#!/usr/bin/env bash
##############################################################################
# Introduction:
#   Sometimes some applications which generate texinfo files (usually with a
#   filetype of .texi) introduce flaws in the texinfo file. For example,
#   pandoc's (at least as of pandoc 1.19.2.1) generated texinfo files which
#   sometimes had a problem where the name of an anchor and the name used by
#   a reference to that anchor do not always match as they should, especially
#   if the source title for the anchor has spaces or dashes in it. This
#   causes usability problems, especially if and when the texinfo file is
#   fed to the makeinfo utility in order to generate an "info" file (usually
#   with filetype .info). Passing a flawed texinfo file through this script
#   will produce a new textinfo file, which, in many cases, has repaired all
#   such problems.
# 
# Usage:
#     auxfixtexi [options]
#
# Options:
#     -v --version # display version info.
#     -h --help    # display help info.
#     -i --input=  # input file (default is standard input).)
#     -o --output= # output file (default is standard output).
#     -d --debug   # output additional debug messages to stderr.
#     -s --silent  # suppress warning messages to stderr.
#
# Example:
#      auxfixtexi --input=file1.texi --output=file2.texi
#
# Copyright:
#   auxfixtexi Copyright (C) 2017 Eric Alan Christiansen.
#
# Legal:
#   This program comes with ABSOLUTELY NO WARRANTY.
#   This is free software, and you are welcome to use and/or redistribute it
#   under the conditions of the GNU General Public License v3.0.
#   (See https://www.gnu.org/licenses/gpl-3.0.en.html)
#
# More Information:
#   - Pandoc  - See https://github.com/jgm/pandoc/releases.
#   - Texinfo - See https://www.gnu.org/software/texinfo/.
#
# Requirements:
#   - bash version 4 or higher.
#
# Change History:
#   - 2017-07-04 - Original version. Eric Alan Christiansen.
##############################################################################
#
# define functions
#
function put_debug() {
    if [ "$debugflag" == "y" ]; then
        echo "DEBUG: $1" >&2
    fi
    return 0
}
function put_warning() {
    if [ "$silentflag" == "n" ]; then
        echo "WARNING: $1" >&2
    fi
    return 0
}
#
# begin main program
#
ifsorg="$IFS"
lf=$'\x0a'   # ascii linefeed character
cmdfile=$(readlink -f "$0")
cmddir=$(dirname "$cmdfile")
cmdname="${cmdfile##*/}"
version="$cmdname version 1.0 (2017-07-04)"
versionflag="n"
helpflag="n"
debugflag="n"
silentflag="n"
infile="/dev/stdin"
outfile="/dev/stdout"
while [ $# -gt 0 ]; do
    param="$1"
    shift
    if [[ "$param"   == "--version" || "$param" == "-v" ]]; then
        versionflag="y"
    elif [[ "$param" == "--help"    || "$param" == "-h" ]]; then
        helpflag="y"
    elif [[ "$param" == "--debug"   || "$param" == "-d" ]]; then
        debugflag="y"
    elif [[ "$param" == "--silent"  || "$param" == "-s" ]]; then
        silentflag="y"
    elif [[ "$param" == "-i"                            ]]; then
        infile="$1"
        shift
    elif [[ "$param" == "-o"                            ]]; then
        outfile="$1"
        shift
    elif [[ "$param" =~ ^--input=.+$ ]];  then
        outfile="${param:9}"
    elif [[ "$param" =~ ^--output=.+$ ]]; then
        outfile="${param:10}"
    else
        echo "ERROR: bad command line option ($param)." >&2
        exit 1
    fi
done
#
# show version if it was requested
#
if [ "$versionflag" == "y" ]; then
    echo "$version"
fi
#
# show help if it was requested
#
if [ "$helpflag" == "y" ]; then
    echo "Command:"
    echo "  $cmdname - Fix references in a Texi document generated by Pandoc"
    echo "Syntax:"
    echo "  $cmdname -h | --help     # display this help text."
    echo "  $cmdname -v | --version  # display program version information."
    echo "  $cmdname [<option>...]   # do a GitHub release (or dryrun)."
    echo "Options:"
    echo "  -h | --help      # display this help screen."
    echo "  -v | --version   # display program version information."
    echo "  -s | --silent    # suppress warning messages to stderr."
    echo "  -d | --debug     # output debug info to stderr."
    echo "  -i <file>        # read input from <file> instead of standard input."
    echo "  --input=<file>   # read input from <file> instead of standard input."
    echo "  -o <file>        # write output to <file> instead of standard output."
    echo "  --output=<file>  # write output to <file> instead of standard output."
fi
#
# if --help or --version and no files specified, assume we are done.
#
if [[ "$versionflag" == "y" || "$helpflag" == "y" ]]; then
    exit 0
fi
#
# declare and initialize arrays
#
declare -a inlines=()
declare -a outlines=()
declare -A refnames1=()
declare -A refnames2=()
declare -A anchornames1=()
declare -A anchornames2=()
#
# read all input into array buffer
#
while read line; do
    inlines+=("$line")    # add line to array buffer
done < "$infile"
#
# scan through inlines saving all "refs" found
#
linecnt=${#inlines[@]}
put_debug "$linecnt lines read from $infile."
idx=$((0))
while [[ $idx -lt $linecnt ]]; do
    line="${inlines[$idx]}"
    idx=$(($idx+1))
    if [[ "$line" =~ ^.*\@ref\{\#.+$ ]]; then
        #put_debug "ref: $line"
        linenoprefix=$(echo "$line" | sed 's/^.*\@ref{\#//')
        prefixlen=$((${#line}-${#linenoprefix}))
        prefix="${line:0:$prefixlen}"
        refname=$(echo "$linenoprefix" | sed 's/,.*$//')
        refnamelen="${#refname}"
        suffix="${linenoprefix:$refnamelen}"
        #put_debug "prefix: '$prefix'"
        #put_debug "refnam: '$refname'"
        #put_debug "suffix: '$suffix'"
        newname=$(echo "$refname" | sed 's/[\ \t-]//g')  # remove spaces, tabs, and dashes
        newline="${prefix}${newname}${suffix}"
        outlines+=("$newline")
        # save old to new and new to old name maps
        refnames1["$refname"]="$newname"
        refnames2["$newname"]="$refname"
    elif [[ "$line" =~ ^.*\@anchor\{\#.+$ ]]; then
        #put_debug "anchor: $line"
        linenoprefix=$(echo "$line" | sed 's/^.*\@anchor{\#//')
        prefixlen=$((${#line}-${#linenoprefix}))
        prefix="${line:0:$prefixlen}"
        refname=$(echo "$linenoprefix" | sed 's/}.*$//')
        refnamelen="${#refname}"
        suffix="${linenoprefix:$refnamelen}"
        #put_debug "prefix: '$prefix'"
        #put_debug "refnam: '$refname'"
        #put_debug "suffix: '$suffix'"
        newname=$(echo "$refname" | sed 's/[\ \t-]//g')  # remove spaces, tabs, and dashes
        newline="${prefix}${newname}${suffix}"
        outlines+=("$newline")
        # save old to new and new to old name maps
        anchornames1["$refname"]="$newname"
        anchornames2["$newname"]="$refname"
    else
        outlines+=("$line")
    fi
done
#
# now do some reference usage analysis
#
# see how many names we have
anchoroldcnt="${#anchornames1[@]}"
anchornewcnt="${#anchornames2[@]}"
refoldcnt="${#refnames1[@]}"
refnewcnt="${#refnames2[@]}"
put_debug "$anchoroldcnt unique old anchor names."
put_debug "$anchornewcnt unique new anchor names."
put_debug "$refoldcnt unique old ref names."
put_debug "$refnewcnt unique new ref names."
# count how many anchor names changed
anchorchangecnt=$((0))
oldanchornoref=$((0))
for oldname in "${!anchornames1[@]}"; do
    newname="${anchornames1[$oldname]}"
    if [ "$oldname" != "$newname" ]; then
        anchorchangecnt=$(($anchorchangecnt+1))
    fi
    # check if there is a matching old ref
    if [ ! ${refnames1["$oldname"]+_} ]; then
        oldanchornorefcnt=$(($oldanchornorefcnt+1))
    fi
done
put_debug "$anchorchangecnt anchor names changed."
put_debug "$oldanchornorefcnt old anchor names were not used by any refs."
# count how many ref names changed or did not have matching anchor
refchangecnt=$((0))
oldrefnoanchorcnt=$((0))
for oldname in "${!refnames1[@]}"; do
    newname="${refnames1[$oldname]}"
    if [ "$oldname" != "$newname" ]; then
        refchangecnt=$(($refchangecnt+1))
    fi
    # check if there is a matching old anchor
    if [ ! ${anchornames1["$oldname"]+_} ]; then
        oldrefnoanchorcnt=$(($oldrefnoanchorcnt+1))
    fi
done
put_debug "$refchangecnt ref names changed."
put_debug "$oldrefnoanchorcnt old ref names did not match any anchors."
# count how well the new names match
newanchornorefcnt=$((0))
for newname in "${!anchornames2[@]}"; do
    oldname="${anchornames2[$newname]}"
    # check if there is a matching new ref
    if [ ! ${refnames2["$newname"]+_} ]; then
        newanchornorefcnt=$(($newanchornorefcnt+1))
    fi
done
put_debug "$newanchornorefcnt new anchor names were not used by any refs."
newrefnoanchorcnt=$((0))
for newname in "${!refnames2[@]}"; do
    oldname="${refnames2[$newname]}"
    # check if there is a matching new ref
    if [ ! ${anchornames2["$newname"]+_} ]; then
        newrefnoanchorcnt=$(($newrefnoanchorcnt+1))
    fi
done
put_debug "$newrefnoanchorcnt new ref names did not match any anchors."
#
# now output the new array lines
#
linecnt=$((0))
for line in "${outlines[@]}"; do
    linecnt=$(($linecnt+1))
    if [ "$outfile" == "/dev/stdout" ]; then
        echo "$line"
    elif [[ $linecnt -eq 1 ]]; then
        echo "$line" > "$outfile"
    else
        echo "$line" >> "$outfile"
    fi
done
# warn if the number of unique anchors changed
if [ "${#anchornames1[@]}" != "${#anchornames2[@]}" ]; then
    put_warning "Number of unique anchor names changed from ${#anchornames1[@]} to ${#anchornames2[@]}."
fi
# warn if the number of unique refs changed
if [ "${#refnames1[@]}" != "${#refnames2[@]}" ]; then
    put_warning "Number of unique ref names changed from ${#refnames1[@]} to ${#refnames2[@]}."
fi
# warn if there are any refs which do not match an anchor
if [[ $newrefnoanchorcnt -ne 0 ]]; then
    put_warning "$newrefnoanchorcnt new ref names did not match any anchors."
fi
exit 0
