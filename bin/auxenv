# auxenv - A "sourceable" bash script to show and setup environment variables
#
# define all logic in a function to isolate local variables
#
function auxenv_main_func() {
    local action
    local scriptname
    local scriptspec
    local envname
    local part
    local subpart
    local newdir
    local olddir
    local result
    local cnt
    local dupflag
    local foundflag
    local existsflag
    local intflag
    local insertedflag
    local befaft
    local re
    local tgtcnt
    local remcnt
    local workpath
    local revflag
    local IFS
    #
    # get base script name
    #
    scriptname=${BASH_SOURCE[0]##*/}  # just keep basename part
    scriptspec=${BASH_SOURCE[0]}      # full spec
    #
    # look on command line for user selected action
    #
    action="$1"
    if [ -z "$action" ]; then action="help"; fi
    action=${action,,}   # lowercase action
    #
    # do appropriate action
    #
    if [ "$action" == "version" ]; then
        echo "$scriptname version 1.5 (2017-06-22)"
        return 0
    elif [ "$action" == "help" ]; then
        if [ ! -z "$2" ]; then
            echo "ERROR: Too many command line parameters." >&2
            return 1
        fi
        echo "Command:"
        echo "  $scriptname - A sourceable bash script to display/setup environment variables."
        echo "Syntax:"
        echo "  $scriptname <command> [<option> [<option>] ...]"
        echo "Commands:"
        echo "  help                          # display script usage help."
        echo "  version                       # display script version."
        echo "  show    <envname>             # display environment var readably."
        echo "  dump    <envname>             # display environment var basically."
        echo "  prepend <envname> <dir>       # prepend directory to env var."
        echo "  append  <envname> <dir>       # prepend directory to env var."
        echo "  remove  <envname> <dir> [<n>] # remove directory up to n times."
        echo "  dedup   <envname> [<n>]       # deduplicate, n>=0 from top, n<0 from bottom."
        echo "  desym   <envname>             # dereference all symbolic links."
        echo "  weed    <envname>             # weed directories that do not exist."
        echo "  insert  <envname> <dir> before <olddir> # add dir before olddir."
        echo "  insert  <envname> <dir> after  <olddir> # add dir after olddir."
        echo "  insert  <envname> <dir> before <pos>    # add dir before position."
        echo "  insert  <envname> <dir> after  <pos>    # add dir after position."
        echo "  count   <envname> [<dir>]     # count all entries of occurances of dir."
        echo "  find    <envname> <dir>       # get position of directory."
        echo "  get     <envname> <pos>       # get entry at position."
        echo "  reverse <envname>             # reverse order of all entries."
        echo "  clean   <envname>             # does desym, dedup, and weed in one step."
        return 0
    elif [ "$action" == "show" ]; then
        envname="$2"
        if [ -z "$envname" ]; then
            echo "ERROR: Missing environment variable name parameter." >&2
            return 1
        fi
        if [ ! -z "$3" ]; then
            echo "ERROR: Too many command line parameters." >&2
            return 1
        fi
        echo "**** $envname is set to:"
        echo "${!envname}"
        IFS=":"
        let cnt=0
        for part in ${!envname}; do
            let cnt=$cnt+1
            if [ "$cnt" == "1" ]; then echo "** Part breakdown:"; fi
            echo "  $cnt=$part"
        done
        return 0
    elif [ "$action" == "dump" ]; then
        envname="$2"
        if [ -z "$envname" ]; then
            echo "ERROR: Missing environment variable name parameter." >&2
            return 1
        fi
        if [ ! -z "$3" ]; then
            echo "ERROR: Too many command line parameters." >&2
            return 1
        fi
        IFS=":"
        let cnt=0
        for part in ${!envname}; do
            let cnt=$cnt+1
            echo "$part"
        done
        return 0
    elif [ "$action" == "append" ]; then
        envname="$2"
        if [ -z "$envname" ]; then
            echo "ERROR: Missing environment variable name parameter." >&2
            return 1
        fi
        newdir="$3"
        if [ -z "$newdir" ]; then
            echo "ERROR: Missing new directory parameter." >&2
            return 1
        fi
        if [ ! -z "$4" ]; then
            echo "ERROR: Too many command line parameters." >&2
            return 1
        fi
        if [ -z "${!envname}" ]; then
            export $envname="$newdir"
        else
            export $envname="${!envname}:$newdir"
        fi
        return 0
    elif [ "$action" == "prepend" ]; then
        envname="$2"
        if [ -z "$envname" ]; then
            echo "ERROR: Missing environment variable name parameter." >&2
            return 1
        fi
        newdir="$3"
        if [ -z "$newdir" ]; then
            echo "ERROR: Missing new directory parameter." >&2
            return 1
        fi
        if [ ! -z "$4" ]; then
            echo "ERROR: Too many command line parameters." >&2
            return 1
        fi
        if [ -z "${!envname}" ]; then
            export $envname="$newdir"
        else
            export $envname="$newdir:${!envname}"
        fi
        return 0
    elif [ "$action" == "remove" ]; then
        envname="$2"
        if [ -z "$envname" ]; then
            echo "ERROR: Missing environment variable name parameter." >&2
            return 1
        fi
        newdir="$3"
        if [ -z "$newdir" ]; then
            echo "ERROR: Missing directory to remove parameter." >&2
            return 1
        fi
        tgtcnt="$4"
        if [ -z "$tgtcnt" ]; then
            let tgtcnt=999999
        else
            re='^[0-9]+$'
            if [[ ! $tgtcnt =~ $re ]]; then
                echo "ERROR: Count parameter must be positive integer." >&2
                return 1
            fi
        fi
        if [ ! -z "$5" ]; then
            echo "ERROR: Too many command line parameters." >&2
            return 1
        fi
        result=""
        IFS=":"
        let remcnt=0
        for part in ${!envname}; do
            if [ "$part" != "$newdir" ]; then
                result="$result:$part"
            else
                if [ "$remcnt" -ge "$tgtcnt" ]; then
                    result="$result:$part"
                else
                    let remcnt=$remcnt+1
                fi
            fi
        done
        result=${result:1}  # strip leading :
        export $envname="$result"
        return 0
    elif [ "$action" == "dedup" ]; then
        envname="$2"
        if [ -z "$envname" ]; then
            echo "ERROR: Missing environment variable name parameter." >&2
            return 1
        fi
        tgtcnt="$3"
        if [ -z "$tgtcnt" ]; then tgtcnt=1; fi    # default
        re='^\-?[0-9]+$'
        if [[ ! $tgtcnt =~ $re ]]; then
            echo "ERROR: Missing n times parameter." >&2
        fi
        if [ "$tgtcnt" == "0" ]; then tgtcnt="1"; fi  # change zero to one
        if [ ! -z "$4" ]; then
            echo "ERROR: Too many command line parameters." >&2
            return 1
        fi
        result=""
        IFS=":"
        revflag="n"
        workpath=${!envname}
        if [ "$tgtcnt" -lt "0" ]; then
            revflag="y"
            let tgtcnt=$tgtcnt*-1
            workpath=""
            for part in ${!envname}; do
                # reverse order
                workpath="$part:$workpath"
            done
            workpath=${workpath::-1}  # trim trailing :
        fi
        result=""
        for part in ${workpath}; do
            dupflag="n"
            for subpart in $result; do
                if [ "$part" == "$subpart" ]; then
                    dupflag="y"
                    break
                fi
            done
            if [ "$dupflag" == "n" ]; then
                result="$result:$part"
            fi
        done
        result=${result:1}  # strip leading :
        if [ "$revflag" == "y" ]; then
            # reverse back
            workpath="$result"
            result=""
            for part in ${workpath}; do
                result="$part:$result"
            done
            result=${result::-1}  # trim trailing :
        fi
        export $envname="$result"
        return 0
    elif [ "$action" == "desym" ]; then
        envname="$2"
        if [ -z "$envname" ]; then
            echo "ERROR: Missing environment variable name parameter." >&2
            return 1
        fi
        if [ ! -z "$4" ]; then
            echo "ERROR: Too many command line parameters." >&2
            return 1
        fi
        cnt="0"
        result=""
        workpath=${!envname}
        IFS=":"
        for part in ${workpath}; do
            # try to dereference unless part is "." (current directory)
            if [ "$part" != "." ]; then
                part=$(readlink -f "$part")
            fi
            result="$result:$part"
        done
        result=${result:1}  # strip leading :
        export $envname="$result"
        return 0
    elif [ "$action" == "weed" ]; then
        envname="$2"
        if [ -z "$envname" ]; then
            echo "ERROR: Missing environment variable name parameter." >&2
            return 1
        fi
        if [ ! -z "$3" ]; then
            echo "ERROR: Too many command line parameters." >&2
            return 1
        fi
        result=""
        IFS=":"
        for part in ${!envname}; do
            existsflag="n"
            if [ -d "$part" ]; then
                if [ -z "$result" ]; then
                    result="$part"
                else
                    result="$result:$part"
                fi
            fi
        done
        export $envname="$result"
        return 0
    elif [ "$action" == "insert" ]; then
        envname="$2"
        if [ -z "$envname" ]; then
            echo "ERROR: Missing environment variable name parameter." >&2
            return 1
        fi
        newdir="$3"
        if [ -z "$newdir" ]; then
            echo "ERROR: Missing new directory parameter." >&2
            return 1
        fi
        befaft="$4"
        if [ -z "$befaft" ]; then
            echo "ERROR: Missing before|after parameter." >&2
            return 1
        fi
        befaft=${befaft,,}  # lowercase
        if [ "$befaft" != "before" ]; then
            if [ "$befaft" != "after" ]; then
                echo "ERROR: before|after parameter not before or after."
                return 1
            fi
        fi
        olddir="$5"
        if [ -z "$olddir" ]; then
            echo "ERROR: Missing existing directory parameter." >&2
            return 1
        fi
        if [ ! -z "$6" ]; then
            echo "ERROR: Too many command line parameters." >&2
            return 1
        fi
        insertedflag="n"
        re='^[0-9]+$'
        intflag="n"
        if [[ $olddir =~ $re ]]; then
            intflag="y"
            tgtcnt="$olddir"
        fi
        result=""
        IFS=":"
        let cnt=0
        for part in ${!envname}; do
            let cnt=$cnt+1
            if [ "$insertedflag" == "y" ]; then
                result="$result:$part"
            else
                if [ "$intflag" == "y" ]; then
                    if [ "$cnt" -gt "$tgtcnt" ]; then
                        result="$result:$newdir:$part"
                        insertedflag="y"
                    elif [ "$cnt" -eq "$tgtcnt" ]; then
                        if [ "$befaft" == "before" ]; then
                            result="$result:$newdir:$part"
                        else
                            result="$result:$part:$newdir"
                        fi
                        insertedflag="y"
                    else
                        result="$result:$part"
                    fi
                else
                    if [ "$part" == "$olddir" ]; then
                        if [ "$befaft" == "before" ]; then
                            result="$result:$newdir:$part"
                        else
                            result="$result:$part:$newdir"
                        fi
                        insertedflag="y"
                    else
                        result="$result:$part"
                    fi
                fi
            fi
        done
        if [ "$insertedflag" == "n" ]; then result="$result:$newdir"; fi
        if [ "${result:0:1}" == ":" ]; then result="${result:1}"; fi
        export $envname="$result"
        return 0
    elif [ "$action" == "count" ]; then
        envname="$2"
        if [ -z "$envname" ]; then
            echo "ERROR: Missing environment variable name parameter." >&2
            return 1
        fi
        olddir="$3"   # optional
        if [ ! -z "$4" ]; then
            echo "ERROR: Too many command line parameters." >&2
            return 1
        fi
        IFS=":"
        let cnt=0
        for part in ${!envname}; do
            if [ -z "$olddir" ]; then
                let cnt=$cnt+1
            else
                if [ "$part" == "$olddir" ]; then
                    let cnt=$cnt+1
                fi
            fi
        done
        echo "$cnt"
        return 0
    elif [ "$action" == "find" ]; then
        envname="$2"
        if [ -z "$envname" ]; then
            echo "ERROR: Missing environment variable name parameter." >&2
            return 1
        fi
        olddir="$3"
        if [ -z "$olddir" ]; then
            echo "ERROR: Missing directory parameter." >&2
            return 1
        fi
        if [ ! -z "$4" ]; then
            echo "ERROR: Too many command line parameters." >&2
            return 1
        fi
        IFS=":"
        let cnt=0
        let tgtcnt=0
        for part in ${!envname}; do
            let cnt=$cnt+1
            if [ "$part" == "$olddir" ]; then
                tgtcnt="$cnt"
                break
            fi
        done
        echo "$tgtcnt"
        return 0
    elif [ "$action" == "get" ]; then
        envname="$2"
        if [ -z "$envname" ]; then
            echo "ERROR: Missing environment variable name parameter." >&2
            return 1
        fi
        tgtcnt="$3"
        if [ -z "$tgtcnt" ]; then
            echo "ERROR: Missing position parameter." >&2
            return 1
        fi
        if [ ! -z "$4" ]; then
            echo "ERROR: Too many command line parameters." >&2
            return 1
        fi
        re='^[0-9]+$'
        if [[ $tgtcnt =~ $re ]]; then
            intflag="y"
        else
            intflag="n"
            echo "ERROR: Position parameter must be an integer." >&2
            return 1
        fi
        IFS=":"
        let cnt=0
        for part in ${!envname}; do
            let cnt=$cnt+1
            if [ "$cnt" -eq "$tgtcnt" ]; then
                echo "$part"
                break
            fi
        done
        return 0
    elif [ "$action" == "reverse" ]; then
        envname="$2"
        if [ -z "$envname" ]; then
            echo "ERROR: Missing environment variable name parameter." >&2
            return 1
        fi
        if [ ! -z "$3" ]; then
            echo "ERROR: Too many command line parameters." >&2
            return 1
        fi
        result=""
        IFS=":"
        for part in ${!envname}; do
            result="$part:$result"
        done
        if [ ! -z "$result" ]; then
            result=${result::-1}  # trim trailing :
            export $envname="$result"
        fi
        return 0
    elif [ "$action" == "clean" ]; then
        # does desym, dedup, and weed in one step."
        envname="$2"
        if [ -z "$envname" ]; then
            echo "ERROR: Missing environment variable name parameter." >&2
            return 1
        fi
        if [ ! -z "$3" ]; then
            echo "ERROR: Too many command line parameters." >&2
            return 1
        fi
        source "$scriptspec" desym $envname
        source "$scriptspec" dedup $envname
        source "$scriptspec" weed  $envname
        return 0
    else
        echo "ERROR: Unrecognized command line action specified ($action)." >&2
        return 1
    fi
}
#
# Now invoke the main function
#
auxenv_main_func $@
if [ "$?" == "0" ]; then
    unset auxenv_main_func
    return 0
else
    unset auxenv_main_func
    return 1
fi
